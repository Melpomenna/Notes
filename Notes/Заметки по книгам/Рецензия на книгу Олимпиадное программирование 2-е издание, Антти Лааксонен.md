#Алгоритмы 
# 1 глава, Введение
Была вводной, рассказывала об основных мероприятиях и соревнованиях в рамках Олимпиадного программирования и какие там есть правила
Из самых крупных турниров это:
	1. ICPC - международная студенческая олимпиада
	2. IOI - международная олимпиада по информатике

# 2 глава, Техники программирования

#Cpp 

Рассказывается про языковые средства языка c++, сильно отличается от толкового программирования, но для олимпиады нужно решение, поэтому как совет сойдет
рассказали про ввод и вывод и то, что его можно ускорить с помощь конструкций:
```c++
std::ios::syn_with_stdio(0);
std::cin.tie(0);
```

#TODO 
Нужно почитать исходные код и посмотреть что они делают

Рассказали про работу с числами, в целом не большая база - какие типы данных стоит использовать и почему

Рассказывали про сокращение кода и макросы, в целом не совсем согласен с ними, т.к. при должно уровне быстро писать код не такая уж и проблема, так что скорее вредные чем полезный совет

Рассказали про рекурсию, на примере было:

Порождение множества:

```c++
void search(int k)
{
  if (k == n+1) // n -  количество элементов, в целом можно и в функцию передавать
  {
    // обработать множество
  } else {
    subset.push_back(k);
    search(k+1);
    subset.pop_back();
    search(k+1);
  }
}

```

Порождение  перестановок:
```c++

void search()
{
  if (permutation.size() == n)
  {
   // обработать перестановку
  } else {
   for(int i = 1; i <= n; ++i) {
	   if (chosen[i]) 
		   continue;
		chosen[i] = true;
		permutation.push_back(i);
		search();
		chosen[i] = false;
		permutation.pop_back();
   }
  }
}

```

В c++ так же есть стандартная функция по генерации перестановок:
***std::next_permutation***

Рассказали про алгоритм "перебора с возвратом" - начинает работу с пустого решения и шаг ща шагом расширяет его.
Как пример - решение задачи про расставления n ферзей, на доске nxn, так чтобы никакие 2 не били друг друга.

```c++
void search(int y)
{
	 if (y == n) {
	  count++;
	  return;
	 }
	 for(int x = 0; x < n; ++x)
	 {
	   if (col[x] || diag1[x+y] || diag2[x-y+n-1])
			continue;
		col[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
		search(y+1);
		col[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
	 }
 }
```

Побитовые операции, рассказали про базовые операции и представление чисел.
Компилятор gcc имеет следующие builtin функции:
1. \_\_builtin_clz - количество нулей в начале двоичного представления
2. \_\_builtin_ctz - количество нулей в конце двоичного представления
3. \_\_builtin_popcount - количество единиц в двоичном представлении
4. \_\_builtin_parity - четность количества единиц в двоичном представлении
Данные функции поддерживают только int, есть версии для long long - с суффиксом ll

Рассказали про множества, про основные операции над ними и представление в виде битов в числе.