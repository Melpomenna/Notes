#Cpp 
[[База Знаний, C++]]

Здесь буду писать встреченные мною вопросы и их полный разбор, часть знаний нужно искать по тегам и по всей базе знаний ^3^

1) Умные указатели
2) Контейнеры
3) Виртуальные методы, vtable
4) Примитивы синхронизации
5) RAII
6) Move семантика
   
   Зачастую описанные выше темы это то, что спрашивают на собеседованиях и то, к чему нужно быть готовым, можно встретится со спецификой, но эти вещи знать нужно для более чем спокойного программирования на c++ (исключая базовое понимание синтаксиса)
   Стоит учесть, что реализация может различаться в зависимости от компилятора.
   В данном случае приведены реализации в компиляторе MSVC 
   начнем:
## RAII

Обычно, если вопрос не задают на прямую.  задают в стиле: "У нас есть какой-то ресурс, мы выделяем память или дескриптор файла и хотелось бы как-то самому не управлять его временем жизни, что можно сделать?"
Ответ на этот вопрос: [идиома RAII (Resource Acquisition Is Initialization)](https://en.cppreference.com/w/cpp/language/raii) - идиоме, говорящая о том, что инициализация всех ресурсов должна происходит при создании объекта (в конструкторе), а отчистка всех ресурсов при разрушении объекта (деструкторе), в целом можно интерпретировать как полное владение над ресурсов, но желательно чтобы точки взаимодействия: инициализация/разрушение ресурсов были явными - конструкторы, деструктор, операторы копирования/перемещения и не в каких больше, т.к. это упрощает логику. На идиоме RAII построены все стандартные контейнеры, а так же умные указатели, потоки.

## Move сементика

Тут обычно вопрос стоит прямо и ответ следующий:
Move семантика - семантика о едином владении над объектов в текущий момент времени
Чтобы было более понятно: мы используем move семантику чтобы у нас был только 1 экземпляр объекта, могут быть побочные эффекты в виде ускорения, но это не основная мысль. Например std::unique_ptr - это RAII с запретом на конструктор копирования, т.к. мы хотим только 1 экземпляр указателя

## Умные указатели

Тут обычно спрашивают так же или прямо, или как бы не управлять памятью самому, на помощь нам приходят умные указатели:
	1. std::unique_ptr - умный указатель который в 1 момент времени хранит только 1 указатель на объект, его нельзя копировать, можно только перемещать. Принимает 2 шаблонных параметра: тип и тип функции - deleter. Так же мы можем передать, какая вызывающая функция будет вызвана в деструкторе объекта. Очень полезно для файловых дескрипторов.
	2. std::shared_ptr - умный указатель который можно копировать и перемещать, реализация в зависимости от компилятора везде разная, но
	  в целом логика работы в не зависимости от компилятора везде одинаковая. Есть счетчик ссылок, при копирования он увеличивается, в деструкторе уменьшается. Как только счетчик ссылок доходит до 0 -объект разрушается.
	  Теперь я расскажу детально как он работает на msvc:
	   класс наследуется от класса \_Ptr_base, он нем чуть позже, может принимать в себя любой другой умный указатель.
	   \_Ptr_base класс имеет следующие объекты:
	   element_type* \_Ptr, и \_Ref_count_base \_Rep
		   1) \_Ptr - указатель на наш объект
		   2) \_Rep - полиморфный класс, который имеет 2 поля: \_Uses, \_Weak, а так же 2 чисто виртуальные функции - \_Destroy, \_Delete_this
		   3) метод \_Decref вызывает \_Destroy и \_Decrefw, если \_Uses равен нулю, то вызываются оба этих метода. В \_Decrefw, если \_Weak равен нулю, то вызывается \_Delete_this. shared_ptr в деструкторе вызывает \_Decref
		   4) Можно установить свой \_Ref_counter используя \_Set_ptr_rep_and_enable_shared (находится в std::shared_ptr)
		так же есть класс \_Ref_count, который наследуется от класса \_Ref_count_base,
		и в конструкторе принимает в себя указатель на объект, в \_Destroy он делает  delete \_ptr, а в \_Delete_this delete this
3. std::weak_ptr - слабая ссылка на указатель, в текущий момент времени мы не имеет гарантии того, жив объект или нет. Можно проверять с помощью метода expired, но после проверки так же нет гарантии того, что объект жив. weak_ptr нужен, что-бы не увеличивать счетчик сильных ссылок для std::shared_ptr, полезно для деревьев, где могут быть цикловые связи, дабы не случилась цикловая ссылочность. в деструкторе вызывает знакомый метод \_Decwref и конструируется себя через std::shared_ptr, передавая указатель и \_Rep
## Виртуальные метода и vtable или же vftable

Можно посмотреть ряд следующий докладов:
1) [ Евгений Ерохин — Back Deep to Basics: Наследование и виртуальность в C++ (Часть 1)](https://www.youtube.com/watch?v=VtC1uXyo7OU) 
2) [ Евгений Ерохин — Back Deep to Basics: Наследование и виртуальность в C++ (Часть 2)]()

vtable или же vftable, она же таблица виртуальных функций, то, чье имя нельзя называть...
Начнем немного из далека представим несколько понятий:
***POD*** - plane of data, это все типы данных, структур, который понимает c компилятор
начиная с 20 стандарта c++ понятие разделилось на 2 термина:
1) ***trivial*** - любой базовый тип данных (не класс или структура) или структура/класс, у которого нет собственного конструктора, деструктора, операторов.
2) ***standart layout*** - класс/структура которая:
3.  не имеет не статических полей с нестандартным выравниванием.
4. не имеет виртуальных функций и полиморфных базовых классов
5. имеет одинаковый контроль доступа для всех не статических полей
6. не имеет базовых классов с нестандартным выравниванием

***Data Layout*** (выравниванием типов) - для всех базовых типов, обычно, размер выравнивания равен размеру типа, могут быть исключения, но это зависит от архитектуры процессора и обычно указана в ABI

Data Layout для структур равен размеру самого большого выравниванию по его полю

В структурах могут быть падинги, происходит этого когда поле в структуры чередуются таким образом, что поле с номером i и j, где sizeof(field\[i]) < sizeof(field\[j]), тогда компилятор между этими полями создает padding, который равен: padding=sizeof(field\[j]) - sizeof(field\[i])
Но мы можем попросить не делать падинги - это называется упаковкой данных. Компилятор для упакованной структуры имеет несколько стратегий, например собирать поля самому, чтобы отсутствовал паддинг, можем вставлять специальные структуры, которые могут осуществлять доступ к не выравненным данным, либо на intel - есть доступ к не выравненным полям (зависит от микроархитектуры)
1) pragma pack:
```cpp
#pragma pack(push,1)
...
#pragma pack(pop)
```
1) атрибут: \_\_attribute\_\_((packed))
2) атрибут: \[\[gnu::packed]]

Снова немного о DataLayout и о сегментах памяти:
Сегмент - место, определенное для определенных типов данных:
.text - код программы
.data -  сегмент данных, отвечающий за инициализированные глобальные, статические переменные.
.bss - сегмент данных, отвечающий за не инициализированные или инициализированные 0 глобальные, статические переменные.
tls - thread local storage, создается под каждый поток, туда отправляются переменные с thread_local модификатором.
Соответсвенно для структуры:
```cpp
struct Buffer
{
 static int globUUID;
 static int globID;
 thread_local short uuid;
  int id;
};
```
По итогу при создании данной структуры на стеке или куче размер будет выделятся только под поле id (int).

При наследовании все структуры будут упаковывать свои данные начиная от родительского класса по иерархии, затем сам класс.

Теперь переходим к полиморфизму:
Динамический полиморфизм - работает с типами известными на стадии компиляции, так и известными только на времени выполнения
Статический полиморфизм -  работает только с типами, известными на этапе компиляции. ***CRTP*** (Curiously recurring template pattern)

***Динамический полиморфизм*** - есть базовый полиморфный класс и дочерний класс, который наследуется от него и переопределяет виртуальные функции

Сигнатура функции - это мангленное имя функции. Манглинг - процесс перевода из 1 имени в другой, имя  - строковый литерал, содержащий имя функции, класс, параметры, namespace и прочее (описано в ABI)

***Динамическая диспетчеризация*** - механизм вызова виртуальных функций:
1) Для каждого класса создаем vtable (массив указателей)
2) Для каждой виртуальной функции создаем jump slot
3) Если в наследуемом классе есть функция с такой же сигнатурой, заменяем слот, в другом случае добавляем новый
4) Вызов функций происходит через vtable

В общем происходит следующее:
Для наследуемого класса vtable копируется и далее для каждой функции происходит создание/обновление jump slot-ов

***Динамический класс*** - класс, имеющий vtable

в Itanium ABI
у объекта, в начале, есть указатель на vtable, а точнее на место, где начинаются сами указатели на его методы
Выше находятся:
typeinfo
offset to top,  нужно для множественного наследования

методы идут в порядке, как мы их декларировали

***nearly empty class*** - почти пустой класс - динамический класс без данных (есть только vptr)

***MDO*** - most derived object - наиболее унаследованный объект

при множественном наследовании сначала идут базовый класс, потом сам класс, потом остальные классы в порядке иерархии
пример:

```cpp
class Wolf
{
 virtual void wooo();
};

class Dog
{
 virtual void wof();
};

class Husky : public Wolf, public Dog
{
 virtual void dragSlay();
};
```

vtable для Husky будет выглядеть вот так:
offset to top = 0
typeinfo Husky
Wolf::wooo - vptf here
Husky::dragSlay
offset to top = -16
typeinfo Husky
Dog:wolf

раскладка данных в vtable:
Данные в под-объектах должны быть разложены так же, как если бы они были автономны
vtable под объекта в родительской vtable должна полностью соответствовать автономной

***primary base class***-  раскладка идет сначала с наследуемого, затем наследник

выбор primary base class происходит следующим образом:
1) Отложим все виртуально-наследуемые классы
2) Пытаемся в порядке непосредственного наследования выбрать первый динамический класс
3) Если нет nearly empty virtual base class , выбирается первый в графе наследования - который не является чьим-то primary, если такого нет, то первый primary

Полный алгоритм раскладки следующий:
если есть primary base - аллоцируем его
если нет primary base и он динамический - аллоцируем vptr
аллоцируем не виртуальные базовые классы в порядке объявления (сами классы аллоцируются тем же алгоритмом)
аллоцируем данные класса
аллоцируем виртуальные базовые классы, но не primary

раскладка vtable:
раскладываем базовый класс
раскладываем наследуемый класс
раскладываем таблицы остальных базовых классов

для виртуальных функций класса:
функции раскладываются в поряжке декларации
implicit-defined assignment operator
iimplicit-defined move operator
implicit-defined destructors

деструктор занимает 2 слота:
вызывающий delete и не вызывающий delete

пример:
```cpp
class X
{
 public:
 int m_x = 1;
virtual int xfn();
};

class Y
{
public:
int m_y = 5;
virtual int fn();
};

class Z : public X, public Y
{
public:
int m_z;
virtual int fn();
};

void call(Y* y) { y->fn(); }
```


```
Z:
vptr X
m_x
vptr Y
m_y
m_z
```

неявным параметром в fn идет указатель на Z (Z* this)
указатель указывает на Y,  а ожидаем Z, который находится на каком-то смещении
и тут на помощью приходит non-vitrual thunk - скорректировать входные параметры
как в этом примере vptr fn указывает на некоторый адаптер, (аббревиатура в манглированном имени Thn16 (n - negative), 16 - смещение
мы добавляем rdi  -16 (this pointer в x86-64 хранится в регистре rdi)
чтобы скорректировать смещение, затем делаем jump на переопределенную функцию
функцию thunk можно заинлайнить, поэтому можно иметь 2 функции (с корректировкой и без)

RTTI - type_info чтобы узнать информацию о типе, match исключений и dynamic_cast
\_\_type_name содержит заманглированное имя

пример:
```
class type_info
{
...
private:
const char* __type_name;
};

class X
{
 public:
 virtual int xfn();
};
```

assmebler x vtabl:
```assembler
_ZTV1X:
 .quad 0
.quad _ZTI1X - указатель на type_info со смещением -1
.quad _ZN1x3xfnEv

_ZTI1X:
.quad _ZTVN10__cxxabiv117__class_type_infoE+16 - vtable type_info
.quad _ZTS1X - type_name

_ZTS1X:
 .asciz "1X" - имя класса замангленное
```

в общем, тяжело....

как выглядит исполняемый файл на примере ELF
Заголовок 
.text - исполняемый код
.data - инициализированные данные
.bss - неинициализированные данные (хранит только размер)
.rela.dyn - динамические релокации
.symtab - таблица символов

При загрузке секции начинают отображаться в память:
.text - 0x10000
.data -  0x20000
.bss - 0x30000

#### ***Релокации***
компилятору известны не все адреса, т.к. некоторые функции могут быть в других единицах трансляции или библиотеках
поэтому перед запуском или при линковке все места таких символов он корректирует адреса с учетом таких дыр (релокации потом выкинет)
В итоговом бинарнике все равно могут быть дыры, но уже динамические (например если символ содержится в динамической библиотеке)
***Динамические релокации*** - при загрузке динамической библиотеки он смотрит (программа) на дыры и применяет на реальные адреса
Выполняет это загрузчик

***Позиционно независимый код*** - в нем инструкции используют непосредственно адреса данных и кода
адреса должны быть известны либо:
1) на момент компиляции
2) на момент загрузки, тогда нужны релокации
***ASLR*** (Address Space Layout Randomization) - перемешивает адреса для безопасности
***PIC*** (position independent code)
мы не используем абсолютные адреса, адресация идет относительно адреса самой инструкции PC (program counter)
Все локации обращения идут через относительную адресацию
внешние адреса выносятся в специальную таблицу ***GOT*** (Global offset table). Ее нам заполняет динамический линковщик
Вызовы внешних функции через небольшие кусочки кода в таблице **PLT** (procedure linkage table), которая берет адрес из GOT
Теперь .text и .plt становятся разделяемыми
.rodata - read-only data - содержит константные данные
.relro - relocate and read only - загрузчик применяет все релокации и меняет защиту страниц на Read Only. Память не разделяемая. vtable содержится .relro
#### что нового?
#### ***Relative v-table***

давайте хранить не абсолютные адреса, а смещения в vtable (PIC)

clang: ***-fexperimental-relative-c++-abi-vtables*** (уже не experimental), по умолчанию используется в ОС фуксия

RTTI может быть в другой единице трансляции, поэтому мы используем небольшой indirect .rtti_proxy, куда уже помещается адрес (+1 релокация)
плюсы relative vtable:
сокращение по памяти
уменьшается количество релокаций, следовательно скорость загрузки увеличивается

где инстанциируются vtable?
key function (ключевая функция) - первая декларированная не-inline, не чистая, виртуальная функция (где ее тело, в каком cpp)
там же будет компилятор эмитит vtable, если ключевой функции нет, то vtable эмитит в каждом транслируемом файле в секцию COMDAT (потом она на линковке будет установлена в 1 секцию,  rodata или relro)

***virtual table group*** - для полного класса формируются vtable group (класс содержит базовый класс и дальше как описано выше)

#### конструкторы и деструкторы:

ub не происходит при вызове виртуальных функций в конструкторах, деструкторах. Но есть подвохи:

сначала конструируется базовый класс: берет vtable, добавляет к ней смещение, мы записываем данный адрес по this ptr (rdi для x86-64) которая указывает на базовый класс, поэтому при вызове виртуальной функции из конструкторе будет вызов не выше базового класса (если вызывать в базовом классе)
у наследуемого класса, vptr переписывается на новый, поэтому в конструкторе будет валидный вызов виртуальной функции
в деструкторе примерно по такому же принципу: сначала он выставляет vptr наследуемого класса, потом вызывается деструктор базового класса.
Поэтому вызов будет происходить не выше ткущего уровня в наследовании

вспоминаем про offset to top:
используя смещение можем узнать расположение нашего vptr и взять нужную таблицу

## Контейнеры

Здесь будет детальный разбор каждого из следующий контейнеров, более подробную базу о той или иной структуре данных можно найти [[База знаний, Алгоритмы|База знаний, Алгоритмы]]:

	1. std::string
	2. std::vector
	3. красно-черное дерево
		1. std::map
		2. std::set
		3. std::multi_set
		4. std::multi_map
	4. std::array
	5. хеш-таблица
		1. std::unordered_set
		2. std::unordered_map
		3. std::multiunordered_set
		4. std::multiunordered_map
	6. std::list
	7. std::dequeue
	8. std::queue
	9. std::stack

### std::string
std::string - alias на basic_string<char, char_traits<char>, allocator<char>>
в себе хранит 1 поле - _Compressed_pair<_Alty, _Scary_val>, где:
\_Alty - алиас на \_Rebind_alloc_t<_Alloc, _Elem>
_Scary_val - алиас на:
```cpp
_String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer>>>;
```
боятся \_String_val не нужно, т.к. он шаблонным аргумент принимает или \_Simple_types, в зависимости от того, есть ли у аллокатора определенные алисы, если нет, то берет те, что в нем переопределены (сравниваем одни  using на соответствие std::is_same с другими)
Прежде чем говорить о \_Compressed_pair, поговорим для начала о \_String_val:
***\_String_val***:
класс который наследуется от \_Container_base, и шаблонным параметром принимает структуру/класс, которая обязана содержать следующие алиасы:

```cpp
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
```

Про \_Container_base чуть позже, но поговорим, он нам еще понадобится

Данный класс содержит следующие поля:
```cpp
    _Bxty _Bx;

    // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
    // neither _Mysize nor _Myres takes account of the extra null terminator
    size_type _Mysize = 0; // current length of string (size)
    size_type _Myres  = 0; // current storage reserved for string (capacity)
```

с размером и capacity все  в целом есть:
capacity нужен для аллокаций, размер указывает текущее количество элементов в контейнере
что же такое \_Bxty?
Это union, который содержит 3 поля:
Под словом статический означает выделен на стеке
1) указатель \_Ptr 
2) статический \_Storage размером _BUF_SIZE
3) статический \_Alias размером \_BUF_SIZE, нужен для обеспечения бинарной совместимости (особенно /clr)
   \_BUF_SIZE рассчитывается следующим образом:
   
```cpp

_BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);

```
   
В случае с value_type char, \_BUF_SIZE будет равен 16

Если capacity буффера меньше или равен:
\_Small_string_capacity:
```cpp
_Small_string_capacity = _BUF_SIZE - 1
```
то используется \_Storage, в другом случае \_Ptr

За счёт такого метода можно поддержать SSO - small string optimization, т.к. теперь нам не нужны аллокации и все данные находятся на стеке

Поговорим теперь о том, что такое  \_Container_base
В зависимости от  значения:
```cpp
_ITERATOR_DEBUG_LEVEL
```
это алиас или:
если данный макрос равен 0:
\_Container_base0
в другом случае:
\_Container_base12

\_Container_base0 достаточно простая структура, имеющая следующую реализацию:
```
struct _Container_base0 {
    _CONSTEXPR20 void _Orphan_all() noexcept {}
    _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    _CONSTEXPR20 void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};
```

с \_Container_base12 все чуть сложнее:
Он содержит указатель на \_Container_proxy, с  названием \_Myproxy
сама прокся это тоже достаточнно простой класс:
```cpp
struct _Container_proxy { // store head of iterator chain and back pointer
    _CONSTEXPR20 _Container_proxy() noexcept = default;
    _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

```

Теперь поговорим о функциональности \_Container_base12:

***\_Orphan_all:***
В зависимости от того, поддержана ли contant_evaluated (c++20):
функция is_constant_evaluated
будет вызван или:
\_Orphan_all_unlocked_v3 или \_Orphan_all_locked_v3, значение  \_ITERATOR_DEBUG_LEVEL должно быть равно 2, в целом разница 1 от другого в том, что  \_Orphan_all_locked_v3 создает объект \_Lockit с дебаг уровнем 3
Данные методы делают следующее:
проходятся по итераторам в прокси объекте и зануляют их, саму проксю тоже
Зачем это? Чуть позже


***\_Swap_proxy_and_iterators:***
В поведение метода аналогично с \_Orphan_all, сама логика другая:
меняет свой прокси объект, на прокси другого

***\_Alloc_proxy:***
Создает новый прокси объект используя аллоктор, \_Mycont указывает всегда на this объект

***\_Reload_proxy:***
Создает новый прокси объект используя новый аллокатор, аналогично с \_Alloc_proxy, но очищает старый прокси объект

теперь про \_Iterator_base12, фактически это односвязный список из набора итераторов и прокси объектов, поэтому \_Container_base_12 содержит root ноду данного списка
Ну чтож, мы столько разобрали, но к самой реализации std::string еще не подошли, а нам осталось разобрать класс обертку \_Compressed_pair, после чего можно перейти к реализации std::string

***\_Compressed_pair*** - шаблонный класс который принимает 3 аргумента, тип T1, T2 и bool
Формально очень похоже на std::pair, но, если T1 пустой класс/структура и не final, тогда класс наследуется приватно от T1 и полем содержит T2, в другом случае:
если T1 не пуст или final, то содержит 2 поля с типами T1 и T2

Ну чтож, наконец-то можно перейти к самому классу basic_string
мы рассмотрим следующие возможности:
конструкторы, операторы, деструктор, вставка, удаление, поиск:
Конструкторы