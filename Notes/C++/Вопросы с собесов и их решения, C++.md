#Cpp 
[[База Знаний, C++]]

Здесь буду писать встреченные мною вопросы и их полный разбор, часть знаний нужно искать по тегам и по всей базе знаний ^3^

1) Умные указатели
2) Контейнеры
3) Виртуальные методы, vtable
4) Примитивы синхронизации
5) RAII
6) Move семантика
   
   Зачастую описанные выше темы это то, что спрашивают на собеседованиях и то, к чему нужно быть готовым, можно встретится со спецификой, но эти вещи знать нужно для более чем спокойного программирования на c++ (исключая базовое понимание синтаксиса)
   начнем:
## RAII

Обычно, если вопрос не задают на прямую.  задают в стиле: "У нас есть какой-то ресурс, мы выделяем память или дескриптор файла и хотелось бы как-то самому не управлять его временем жизни, что можно сделать?"
Ответ на этот вопрос: [идиома RAII (Resource Acquisition Is Initialization)](https://en.cppreference.com/w/cpp/language/raii) - идиоме, говорящая о том, что инициализация всех ресурсов должна происходит при создании объекта (в конструкторе), а отчистка всех ресурсов при разрушении объекта (деструкторе), в целом можно интерпретировать как полное владение над ресурсов, но желательно чтобы точки взаимодействия: инициализация/разрушение ресурсов были явными - конструкторы, деструктор, операторы копирования/перемещения и не в каких больше, т.к. это упрощает логику. На идиоме RAII построены все стандартные контейнеры, а так же умные указатели, потоки.

## Move сементика

Тут обычно вопрос стоит прямо и ответ следующий:
Move семантика - семантика о едином владении над объектов в текущий момент времени
Чтобы было более понятно: мы используем move семантику чтобы у нас был только 1 экземпляр объекта, могут быть побочные эффекты в виде ускорения, но это не основная мысль. Например std::unique_ptr - это RAII с запретом на конструктор копирования, т.к. мы хотим только 1 экземпляр указателя

## Умные указатели

Тут обычно спрашивают так же или прямо, или как бы не управлять памятью самому, на помощь нам приходят умные указатели:
	1. std::unique_ptr - умный указатель который в 1 момент времени хранит только 1 указатель на объект, его нельзя копировать, можно только перемещать. Принимает 2 шаблонных параметра: тип и тип функции - deleter. Так же мы можем передать, какая вызывающая функция будет вызвана в деструкторе объекта. Очень полезно для файловых дескрипторов.
	2. std::shared_ptr - умный указатель который можно копировать и перемещать, реализация в зависимости от компилятора везде разная, но
	  в целом логика работы в не зависимости от компилятора везде одинаковая. Есть счетчик ссылок, при копирования он увеличивается, в деструкторе уменьшается. Как только счетчик ссылок доходит до 0 -объект разрушается.
	  Теперь я расскажу детально как он работает на msvc:
	   класс наследуется от класса \_Ptr_base, он нем чуть позже, может принимать в себя любой другой умный указатель.
	   \_Ptr_base класс имеет следующие объекты:
	   element_type* \_Ptr, и \_Ref_count_base \_Rep
		   1) \_Ptr - указатель на наш объект
		   2) \_Rep - полиморфный класс, который имеет 2 поля: \_Uses, \_Weak, а так же 2 чисто виртуальные функции - \_Destroy, \_Delete_this
		   3) метод \_Decref вызывает \_Destroy и \_Decrefw, если \_Uses равен нулю, то вызываются оба этих метода. В \_Decrefw, если \_Weak равен нулю, то вызывается \_Delete_this. shared_ptr в деструкторе вызывает \_Decref
		   4) Можно установить свой \_Ref_counter используя \_Set_ptr_rep_and_enable_shared (находится в std::shared_ptr)
		так же есть класс \_Ref_count, который наследуется от класса \_Ref_count_base,
		и в конструкторе принимает в себя указатель на объект, в \_Destroy он делает  delete \_ptr, а в \_Delete_this delete this
3. std::weak_ptr - слабая ссылка на указатель, в текущий момент времени мы не имеет гарантии того, жив объект или нет. Можно проверять с помощью метода expired, но после проверки так же нет гарантии того, что объект жив. weak_ptr нужен, что-бы не увеличивать счетчик сильных ссылок для std::shared_ptr, полезно для деревьев, где могут быть цикловые связи, дабы не случилась цикловая ссылочность. в деструкторе вызывает знакомый метод \_Decwref и конструируется себя через std::shared_ptr, передавая указатель и \_Rep
## Виртуальные метода и vtable или же vftable

Можно посмотреть ряд следующий докладов:
1) [ Евгений Ерохин — Back Deep to Basics: Наследование и виртуальность в C++ (Часть 1)](https://www.youtube.com/watch?v=VtC1uXyo7OU) 
2) [ Евгений Ерохин — Back Deep to Basics: Наследование и виртуальность в C++ (Часть 2)]()

vtable или же vftable, она же таблица виртуальных функций, то, чье имя нельзя называть...
Начнем немного из далека представим несколько понятий:
***POD*** - plane of data, это все типы данных, структур, который понимает c компилятор
начиная с 20 стандарта c++ понятие разделилось на 2 термина:
1) ***trivial*** - любой базовый тип данных (не класс или структура) или структура/класс, у которого нет собственного конструктора, деструктора, операторов.
2) ***standart layout*** - класс/структура которая:
3.  не имеет не статических полей с нестандартным выравниванием.
4. не имеет виртуальных функций и полиморфных базовых классов
5. имеет одинаковый контроль доступа для всех не статических полей
6. не имеет базовых классов с нестандартным выравниванием

***Data Layout*** (выравниванием типов) - для всех базовых типов, обычно, размер выравнивания равен размеру типа, могут быть исключения, но это зависит от архитектуры процессора и обычно указана в ABI

Data Layout для структур равен размеру самого большого выравниванию по его полю

В структурах могут быть падинги, происходит этого когда поле в структуры чередуются таким образом, что поле с номером i и j, где sizeof(field\[i]) < sizeof(field\[j]), тогда компилятор между этими полями создает padding, который равен: padding=sizeof(field\[j]) - sizeof(field\[i])
Но мы можем попросить не делать падинги - это называется упаковкой данных. Компилятор для упакованной структуры имеет несколько стратегий, например собирать поля самому, чтобы отсутствовал паддинг, можем вставлять специальные структуры, которые могут осуществлять доступ к не выравненным данным, либо на intel - есть доступ к не выравненным полям (зависит от микроархитектуры)
1) pragma pack:
```cpp
#pragma pack(push,1)
...
#pragma pack(pop)
```
1) атрибут: \_\_attribute\_\_((packed))
2) атрибут: \[\[gnu::packed]]

Снова немного о DataLayout и о сегментах памяти:
Сегмент - место, определенное для определенных типов данных:
.text - код программы
.data -  сегмент данных, отвечающий за инициализированные глобальные, статические переменные.
.bss - сегмент данных, отвечающий за не инициализированные или инициализированные 0 глобальные, статические переменные.
tls - thread local storage, создается под каждый поток, туда отправляются переменные с thread_local модификатором.
Соответсвенно для структуры:
```cpp
struct Buffer
{
 static int globUUID;
 static int globID;
 thread_local short uuid;
  int id;
};
```
По итогу при создании данной структуры на стеке или куче размер будет выделятся только под поле id (int).

При наследовании все структуры будут упаковывать свои данные начиная от родительского класса по иерархии, затем сам класс.

Теперь переходим к полиморфизму:
Динамический полиморфизм - работает с типами известными на стадии компиляции, так и известными только на времени выполнения
Статический полиморфизм -  работает только с типами, известными на этапе компиляции. ***CRTP*** (Curiously recurring template pattern)

***Динамический полиморфизм*** - есть базовый полиморфный класс и дочерний класс, который наследуется от него и переопределяет виртуальные функции

Сигнатура функции - это мангленное имя функции. Манглинг - процесс перевода из 1 имени в другой, имя  - строковый литерал, содержащий имя функции, класс, параметры, namespace и прочее (описано в ABI)

***Динамическая диспетчеризация*** - механизм вызова виртуальных функций:
1) Для каждого класса создаем vtable (массив указателей)
2) Для каждой виртуальной функции создаем jump slot
3) Если в наследуемом классе есть функция с такой же сигнатурой, заменяем слот, в другом случае добавляем новый
4) Вызов функций происходит через vtable

В общем происходит следующее:
Для наследуемого класса vtable копируется и далее для каждой функции происходит создание/обновление jump slot-ов

***Динамический класс*** - класс, имеющий vtable

в Itanium ABI
у объекта, в начале, есть указатель на vtable, а точнее на место, где начинаются сами указатели на его методы
Выше находятся:
typeinfo
offset to top,  нужно для множественного наследования

методы идут в порядке, как мы их декларировали

***nearly empty class*** - почти пустой класс - динамический класс без данных (есть только vptr)

***MDO*** - most derived object - наиболее унаследованный объект

при множественном наследовании сначала идут базовый класс, потом сам класс, потом остальные классы в порядке иерархии
пример:

```cpp
class Wolf
{
 virtual void wooo();
};

class Dog
{
 virtual void wof();
};

class Husky : public Wolf, public Dog
{
 virtual void dragSlay();
};
```

vtable для Husky будет выглядеть вот так:
offset to top = 0
typeinfo Husky
Wolf::wooo - vptf here
Husky::dragSlay
offset to top = -16
typeinfo Husky
Dog:wolf

раскладка данных в vtable:
Данные в под-объектах должны быть разложены так же, как если бы они были автономны
vtable под объекта в родительской vtable должна полностью соответствовать автономной

***primary base class***-  раскладка идет сначала с наследуемого, затем наследник

выбор primary base class происходит следующим образом:
1) Отложим все виртуально-наследуемые классы
2) Пытаемся в порядке непосредственного наследования выбрать первый динамический класс
3) Если нет nearly empty virtual base class , выбирается первый в графе наследования - который не является чьим-то primary, если такого нет, то первый primary

Полный алгоритм раскладки следующий:
если есть primary base - аллоцируем его
если нет primary base и он динамический - аллоцируем vptr
аллоцируем не виртуальные базовые классы в порядке объявления (сами классы аллоцируются тем же алгоритмом)
аллоцируем данные класса
аллоцируем виртуальные базовые классы, но не primary

раскладка vtable:
раскладываем базовый класс
раскладываем наследуемый класс
раскладываем таблицы остальных базовых классов

для виртуальных функций класса:
функции раскладываются в поряжке декларации
implicit-defined assignment operator
iimplicit-defined move operator
implicit-defined destructors

деструктор занимает 2 слота:
вызывающий delete и не вызывающий delete

пример:
```cpp
class X
{
 public:
 int m_x = 1;
virtual int xfn();
};

class Y
{
public:
int m_y = 5;
virtual int fn();
};

class Z : public X, public Y
{
public:
int m_z;
virtual int fn();
};

void call(Y* y) { y->fn(); }
```


```
Z:
vptr X
m_x
vptr Y
m_y
m_z
```

неявным параметром в fn идет указатель на Z (Z* this)
указатель указывает на Y,  а ожидаем Z, который находится на каком-то смещении
и тут на помощью приходит non-vitrual thunk - скорректировать входные параметры
как в этом примере vptr fn указывает на некоторый адаптер, (аббревиатура в манглированном имени Thn16 (n - negative), 16 - смещение
мы добавляем rdi  -16 (this pointer в x86-64 хранится в регистре rdi)
чтобы скорректировать смещение, затем делаем jump на переопределенную функцию
функцию thunk можно заинлайнить, поэтому можно иметь 2 функции (с корректировкой и без)

RTTI - type_info чтобы узнать информацию о типе, match исключений и dynamic_cast
\_\_type_name содержит заманглированное имя

пример:
```
class type_info
{
...
private:
const char* __type_name;
};

class X
{
 public:
 virtual int xfn();
};
```

assmebler x vtabl:
```assembler
_ZTV1X:
 .quad 0
.quad _ZTI1X - указатель на type_info со смещением -1
.quad _ZN1x3xfnEv

_ZTI1X:
.quad _ZTVN10__cxxabiv117__class_type_infoE+16 - vtable type_info
.quad _ZTS1X - type_name

_ZTS1X:
 .asciz "1X" - имя класса замангленное
```

в общем, тяжело....

как выглядит исполняемый файл на примере ELF
Заголовок 
.text - исполняемый код
.data - инициализированные данные
.bss - неинициализированные данные (хранит только размер)
.rela.dyn - динамические релокации
.symtab - таблица символов

При загрузке секции начинают отображаться в память:
.text - 0x10000
.data -  0x20000
.bss - 0x30000

#### ***Релокации***
компилятору известны не все адреса, т.к. некоторые функции могут быть в других единицах трансляции или библиотеках
поэтому перед запуском или при линковке все места таких символов он корректирует адреса с учетом таких дыр (релокации потом выкинет)
В итоговом бинарнике все равно могут быть дыры, но уже динамические (например если символ содержится в динамической библиотеке)
***Динамические релокации*** - при загрузке динамической библиотеки он смотрит (программа) на дыры и применяет на реальные адреса
Выполняет это загрузчик

***Позиционно независимый код*** - в нем инструкции используют непосредственно адреса данных и кода
адреса должны быть известны либо:
1) на момент компиляции
2) на момент загрузки, тогда нужны релокации
***ASLR*** (Address Space Layout Randomization) - перемешивает адреса для безопасности
***PIC*** (position independent code)
мы не используем абсолютные адреса, адресация идет относительно адреса самой инструкции PC (program counter)
Все локации обращения идут через относительную адресацию
внешние адреса выносятся в специальную таблицу ***GOT*** (Global offset table). Ее нам заполняет динамический линковщик
Вызовы внешних функции через небольшие кусочки кода в таблице **PLT** (procedure linkage table), которая берет адрес из GOT
Теперь .text и .plt становятся разделяемыми
.rodata - read-only data - содержит константные данные
.relro - relocate and read only - загрузчик применяет все релокации и меняет защиту страниц на Read Only. Память не разделяемая. vtable содержится .relro
#### что нового?
#### ***Relative v-table***

давайте хранить не абсолютные адреса, а смещения в vtable (PIC)

clang: ***-fexperimental-relative-c++-abi-vtables*** (уже не experimental), по умолчанию используется в ОС фуксия

RTTI может быть в другой единице трансляции, поэтому мы используем небольшой indirect .rtti_proxy, куда уже помещается адрес (+1 релокация)
плюсы relative vtable:
сокращение по памяти
уменьшается количество релокаций, следовательно скорость загрузки увеличивается

где инстанциируются vtable?
key function (ключевая функция) - первая декларированная не-inline, не чистая, виртуальная функция (где ее тело, в каком cpp)
там же будет компилятор эмитит vtable, если ключевой функции нет, то vtable эмитит в каждом транслируемом файле в секцию COMDAT (потом она на линковке будет установлена в 1 секцию,  rodata или relro)

***virtual table group*** - для полного класса формируются vtable group (класс содержит базовый класс и дальше как описано выше)

#### конструкторы и деструкторы:

ub не происходит при вызове виртуальных функций в конструкторах, деструкторах. Но есть подвохи:

сначала конструируется базовый класс: берет vtable, добавляет к ней смещение, мы записываем данный адрес по this ptr (rdi для x86-64) которая указывает на базовый класс, поэтому при вызове виртуальной функции из конструкторе будет вызов не выше базового класса (если вызывать в базовом классе)
у наследуемого класса, vptr переписывается на новый, поэтому в конструкторе будет валидный вызов виртуальной функции
в деструкторе примерно по такому же принципу: сначала он выставляет vptr наследуемого класса, потом вызывается деструктор базового класса.
Поэтому вызов будет происходить не выше ткущего уровня в наследовании

вспоминаем про offset to top:
используя смещение можем узнать расположение нашего vptr и взять нужную таблицу