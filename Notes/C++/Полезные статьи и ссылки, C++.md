#Cpp 

[Хеш-таблица и C++20](https://habr.com/p/897924/)

1) Использование концептов для более удобного анализа ошибок во время компиляции
2) Использование корутин, для LazyValue
3) применение с rangeы, без циклов (на мой взгляд сомнительно)
4) if constexpr, не совсем удачный, можно просто сделать emplace
5) удаление cv ref cpec через std::remove_cvref_t,  есть CleanKey, в то же время сам key имеет тип Key&&, который может измениться, не совсем понятно зачем
6) std::span для безопасной передачи в insert_range
7) \[\[no_unique_address]\] для аллокатора, для уменьшения размера памяти для объектов без состояния
8) thread-safety через std::atomic_ref<T> (аля lock-free, без mutex)
    
______
   
   [Cpp Standart draft](https://eel.is/c++draft/)
   
______
   
   [Безопасная работа с массивами? Нет, не слышали](https://habr.com/p/895208/)
   
   В примере рассказывалось о примере с использованием двумерного массива и выписки из стандарта, что массив лежит последовательно в памяти и обращение за границу - UB
Соответственно a[0][n] где n > size - UB, хоть и элементы в памяти и должны располагаться последовательно, соответственно результат может быть не самым приятным
Выводы:
Использовать безопасные обертки на типе std::mdspan
Не использовать двумерный массив как одномерный
______

## Как проверить к какому языку относиться h файл?

Нужно проверить существование макроса:  ***__cplusplus***

______

[Делаем собственный анализатор C++ кода в виде плагина для Clang](https://habr.com/p/900224/)

Небольшой гайд по созданию плагина для Clang
1) Рассказывается о преимуществе RecursiveASTVisitor по сравнению с AST matcher (более производительный и удобный по сравнению с AST matcher)
2) Как логировать код плагина: llvm::outs, llvm::errs
В целом больше говорилось о кастомных атрибутах (основная видная мысль)
Но в целом можно взять небольшие выдержки при написании своих плагинов под LLVM

______

[16 байт вместо 32: управляем layout'ом в C++](https://habr.com/p/899784/)
Не плохая статья, рассказывающая основы упаковки данных в структурах, выравнивании, битовых полях, а так же о паддинге
Из интересно подмеченного:
1) Проверка размера структуры во время компиляции, а так же офсета полей в constexpr, можно на этом сделат концеп
2)вывода размера структуры через clang:
clang++ -Xclang -fdump-record-layouts
Хотелось бы услышать про cache-friendly, но там этого не было
На примере показали как упаковать структуру с 32 байт до 16
2) pragma pack(push,1) - отключение выравнивания 
3) Стандартно выравнивание - 8 байт для 64 битных приложений
______

[RAII 2.0: RAII как архитектурный инструмент в C++](https://habr.com/p/901092/)

Представлены примеры идеомы RAII не для ресурсов
А как архитектурный стиль, например для транзакций или отмены асинхронный операций через деструктор
В целом и то и то ресурсы, но если не думать только в рамках ресурсах, а о задачах, то получается безопасное решение
______