#Cpp 

______

для std::function есть правило, чтобы создавался объект используя placement new:
для msvc есть вот такой тип:
```cpp
using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
```
        
Для него выстраиваются правила на аллокацию:

1) 
   ```cpp
   sizeof(_Impl) <= _Space_size, где _Space_size = (_Small_object_num_ptrs - 1) * sizeof(void*),  а _Small_object_num_ptrs = 6 + 16 / sizeof(void*)
```


2) 
   ```cpp
   alignof(_Impl) <= alignof(max_align_t), где max_align_t алиас на double
   ```

3) функция должна быть noexcept

Параметры шаблоны для _Func_impl_no_alloc можно посчитать следующим образом:
```cpp
_Fx - decltype(callable объект)
_Ret - возвращаемый тип лямбды
_Types... - набор параметров вызываемой функции
```


Если все 3 условия выполняются то будет сделан placement new в Storage, хранящий _Small_object_num_ptrs объектов. Если хотя бы 1 не выполняется, то будет произведена аллокация, соответственно это время на синхронизацию дополнительно.

Отсюда в любом случае следует проблемы с std::function:

1) Возвожная аллокация, а для вызова функции постоянное обращение к указателю, который не закеширован скорее всего, частое обращение к std::function, с другими вызовами может привести к потере производительности.

2) Данный вызов не инлайнится, т.к. имеет длинную цепочку вызова, а так же вызов виртуальной функции, в msvc базовый класс помечен __declspec(novtable), поэтому вызова через vtable не будет, нужно посмотреть реализацию в других компиляторах.

Стоит учесть, что _Fx выводиться из шаблона, а не через decltype, поэтому использовать самому может быть проблемой, если только не оборачивать в шаблон


______